<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Screen Alive Steve (Bald Edition)</title>
    <style>
        /* Base page styling - Steve's Skin Tone Background */
        body {
            margin: 0;
            padding: 0;
            background-color: #B07D60;
            display: flex;
            flex-direction: row; 
            width: 100vw;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }

        /* SVG fills the remaining space perfectly */
        svg {
            flex-grow: 1;
            height: 100%;
        }

        /* Force perfect pixel-art rendering on all SVG elements */
        svg * {
            shape-rendering: crispEdges;
        }

        .eye {
            transition: transform 0.12s cubic-bezier(0.25, 1, 0.5, 1);
            will-change: transform;
        }

        /* Minecraft blink: strict vertical squish */
        .blink {
            transform: scaleY(0.1);
        }

        /* Idle Animation: Subtle blocky bounce */
        @keyframes breathe {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-4px); }
        }

        #face-elements {
            animation: breathe 5s steps(2, end) infinite;
        }

        /* --- Sidebar Controls --- */
        #controls {
            width: 260px;
            height: 100vh;
            flex-shrink: 0; 
            background-color: #585858;
            border-right: 4px solid #000000;
            box-shadow: inset 4px 0px 0px #828282; 
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px;
            box-sizing: border-box;
            gap: 20px;
            z-index: 5;
        }

        .sidebar-title {
            font-family: 'Courier New', Courier, monospace;
            color: white;
            margin: 0 0 10px 0;
            font-size: 1.5rem;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
            letter-spacing: 2px;
        }

        .ui-btn {
            width: 100%;
            background-color: #727272;
            color: #ffffff;
            border: 2px solid #000000;
            padding: 12px 15px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            cursor: pointer;
            box-shadow: inset -2px -2px 0px #3A3A3A, inset 2px 2px 0px #9E9E9E;
            text-transform: uppercase;
            transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s;
        }

        .ui-btn:hover {
            background-color: #828282;
        }

        .ui-btn:active {
            box-shadow: inset 2px 2px 0px #3A3A3A, inset -2px -2px 0px #9E9E9E;
            transform: translateY(2px);
        }

        .ui-btn.active-toggle {
            background-color: #4CAF50;
            box-shadow: inset -2px -2px 0px #2E7D32, inset 2px 2px 0px #81C784;
        }

        .ui-btn.active-toggle:active {
            box-shadow: inset 2px 2px 0px #2E7D32, inset -2px -2px 0px #81C784;
        }

        /* Automatically hide the controls when actually in fullscreen */
        :fullscreen #controls { display: none; }
        :-webkit-full-screen #controls { display: none; }
        :-moz-full-screen #controls { display: none; }

        /* UI Overlay for initial audio activation */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #start-btn {
            background-color: #4CAF50;
            color: white;
            border: 3px solid #000;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            cursor: pointer;
            box-shadow: inset -4px -4px 0px #2E7D32, inset 4px 4px 0px #81C784;
            text-transform: uppercase;
            transition: transform 0.1s, background-color 0.1s, box-shadow 0.1s;
        }

        #start-btn:hover {
            background-color: #66BB6A;
        }

        #start-btn:active {
            box-shadow: inset 4px 4px 0px #2E7D32, inset -4px -4px 0px #81C784;
            transform: scale(0.96); 
        }

        #status {
            margin-top: 20px;
            font-size: 1.1rem;
            font-family: 'Courier New', Courier, monospace;
            color: #aaaaaa;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h2 class="sidebar-title">CONTROLS</h2>
        <button id="nav-emo-btn" class="ui-btn">Switch to Emo</button>
        <button id="toggle-mouth-btn" class="ui-btn active-toggle">Mouth Line: ON</button>
        <button id="fullscreen-btn" class="ui-btn">Fullscreen</button>
    </div>

    <div id="overlay">
        <button id="start-btn">Wake Up Steve</button>
        <div id="status">Microphone access required for blocky lip sync.</div>
    </div>

    <svg viewBox="0 0 800 480" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
        <g id="face-elements">
            
            <rect x="340" y="200" width="120" height="60" fill="#8B614A" />

            <rect x="280" y="260" width="60" height="60" fill="#412A1B" />
            <rect x="460" y="260" width="60" height="60" fill="#412A1B" />
            <rect x="340" y="320" width="120" height="60" fill="#412A1B" />

            <g id="left-squint" style="transform-origin: 280px 170px;">
                <g class="eye" style="transform-origin: 280px 170px;">
                    <rect x="220" y="140" width="60" height="60" fill="#ffffff" />
                    <rect x="280" y="140" width="60" height="60" fill="#494697" />
                </g>
            </g>

            <g id="right-squint" style="transform-origin: 520px 170px;">
                <g class="eye" style="transform-origin: 520px 170px;">
                    <rect x="460" y="140" width="60" height="60" fill="#494697" />
                    <rect x="520" y="140" width="60" height="60" fill="#ffffff" />
                </g>
            </g>

            <path id="mouth-path" fill="#1A110B" d="" style="opacity: 1;" />
        </g>
    </svg>

    <script>
    (() => {
        // --- UI & Navigation Logic ---
        const navEmoBtn = document.getElementById('nav-emo-btn');
        navEmoBtn.addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        const fullscreenBtn = document.getElementById('fullscreen-btn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.log(err));
            }
        });

        const toggleMouthBtn = document.getElementById('toggle-mouth-btn');
        let isPermanentMouth = true;

        toggleMouthBtn.addEventListener('click', () => {
            isPermanentMouth = !isPermanentMouth;
            if (isPermanentMouth) {
                toggleMouthBtn.innerText = "Mouth Line: ON";
                toggleMouthBtn.classList.add('active-toggle');
            } else {
                toggleMouthBtn.innerText = "Mouth Line: OFF";
                toggleMouthBtn.classList.remove('active-toggle');
            }
        });

        let wakeLock = null;
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try { wakeLock = await navigator.wakeLock.request('screen'); } 
                catch (err) { console.error(`Wake Lock error: ${err.message}`); }
            }
        }
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        let audioCtx, analyser, freqData, timeData;
        let animationFrameId; 
        
        const mouthPath = document.getElementById('mouth-path');
        const leftSquint = document.getElementById('left-squint');
        const rightSquint = document.getElementById('right-squint');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('status');
        const allEyes = document.querySelectorAll('.eye');

        const mouthCenter = { x: 400, y: 290 };
        const mouthThickness = 30; 
        const defaultMouthWidth = 60; 
        
        let currentMouth = { w: defaultMouthWidth, hTop: 0, hBottom: 0 };
        let targetMouth  = { w: defaultMouthWidth, hTop: 0, hBottom: 0 };
        let currentOpacity = 1.0;
        let targetOpacity = 1.0;
        let currentSquintY = 0.0;
        let targetSquintY = 0.0;

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // --- Core Audio Initialization ---
        async function initializeRobot(isAuto = false) {
            try {
                if (!isAuto) {
                    startBtn.innerText = "Connecting...";
                    statusText.innerText = "Requesting microphone access...";
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                // Save flag to memory so it instantly bypasses next time
                sessionStorage.setItem('micGranted', 'true'); 
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.85; 
                
                source.connect(analyser);
                freqData = new Uint8Array(analyser.frequencyBinCount);
                timeData = new Uint8Array(analyser.frequencyBinCount);
                
                // Ensure overlay is gone
                overlay.style.display = 'none';
                
                await requestWakeLock();

                // If browser suspended audio due to autoplay policies, wake it up on the next physical click anywhere
                if (audioCtx.state === 'suspended') {
                    const resumeAudio = () => {
                        if (audioCtx.state === 'suspended') audioCtx.resume();
                        document.body.removeEventListener('click', resumeAudio);
                        document.body.removeEventListener('touchstart', resumeAudio);
                    };
                    document.body.addEventListener('click', resumeAudio);
                    document.body.addEventListener('touchstart', resumeAudio);
                }

                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(animateFace);
                
                scheduleBlink();

            } catch (err) {
                console.error("Audio initialization failed:", err);
                overlay.style.display = 'flex'; // Bring overlay back if it fails
                if (!isAuto) {
                    statusText.innerText = "Error: Could not access microphone.";
                    startBtn.innerText = "Try Again";
                }
            }
        }

        // Attach manual click
        startBtn.addEventListener('click', () => initializeRobot(false));

        // --- INSTANT Auto-Bypass Logic ---
        async function tryAutoStart() {
            let isGranted = sessionStorage.getItem('micGranted') === 'true';
            
            // If session storage isn't set, try to query the browser permission API
            if (!isGranted && navigator.permissions && navigator.permissions.query) {
                try {
                    const perm = await navigator.permissions.query({ name: 'microphone' });
                    if (perm.state === 'granted') isGranted = true;
                } catch(e) {}
            }

            if (isGranted) {
                // Instantly hide the overlay to prevent the flashing screen
                overlay.style.display = 'none';
                // Start the engine quietly in the background
                initializeRobot(true);
            }
        }
        
        // Run bypass check immediately on load
        tryAutoStart();

        function animateFace() {
            analyser.getByteFrequencyData(freqData);
            analyser.getByteTimeDomainData(timeData);

            let sumSquares = 0;
            for(let i = 0; i < timeData.length; i++) {
                let val = (timeData[i] - 128) / 128; 
                sumSquares += val * val;
            }
            let rms = Math.sqrt(sumSquares / timeData.length);
            let volume = rms * 100; 

            if (volume > 1.5) { 
                let volFactor = Math.min(volume / 15, 1.3); 

                targetOpacity = 1.0;
                targetSquintY = -(volFactor * 4); 

                targetMouth = { 
                    w: defaultMouthWidth, 
                    hTop: 0, 
                    hBottom: 10 + (volFactor * 50) 
                };
            } else {
                targetSquintY = 0.0;
                targetMouth = { w: defaultMouthWidth, hTop: 0, hBottom: 0 };
                targetOpacity = isPermanentMouth ? 1.0 : 0.0;
            }

            currentMouth.w = lerp(currentMouth.w, targetMouth.w, 0.15);
            currentMouth.hBottom = lerp(currentMouth.hBottom, targetMouth.hBottom, 0.15);
            currentSquintY = lerp(currentSquintY, targetSquintY, 0.15);
            currentOpacity = lerp(currentOpacity, targetOpacity, 0.15);

            leftSquint.setAttribute('transform', `translate(0, ${currentSquintY})`);
            rightSquint.setAttribute('transform', `translate(0, ${currentSquintY})`);
            mouthPath.style.opacity = currentOpacity;

            const x1 = mouthCenter.x - currentMouth.w;
            const x2 = mouthCenter.x + currentMouth.w;
            const y1 = mouthCenter.y - mouthThickness; 
            const y2 = mouthCenter.y + mouthThickness + currentMouth.hBottom; 

            const d = `M ${x1} ${y1} L ${x2} ${y1} L ${x2} ${y2} L ${x1} ${y2} Z`;
            mouthPath.setAttribute('d', d);

            animationFrameId = requestAnimationFrame(animateFace);
        }

        function triggerBlink() {
            allEyes.forEach(eye => eye.classList.add('blink'));
            setTimeout(() => {
                allEyes.forEach(eye => eye.classList.remove('blink'));
            }, 120); 
        }

        function scheduleBlink() {
            const nextBlink = Math.random() * 3500 + 2000; 
            setTimeout(() => {
                triggerBlink();
                if (Math.random() < 0.20) {
                    setTimeout(triggerBlink, 200); 
                }
                scheduleBlink();
            }, nextBlink);
        }
    })();
    </script>
</body>
</html>