<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Screen Alive Robot</title>
    <style>
        /* ALL YOUR EXISTING CSS REMAINS EXACTLY THE SAME */
        body { margin: 0; padding: 0; background-color: #000000; display: flex; flex-direction: row; width: 100vw; height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; overflow: hidden; }
        svg { flex-grow: 1; height: 100%; filter: drop-shadow(0 0 25px rgba(0, 255, 255, 0.4)); }
        .eye, #mouth-path { fill: url(#eyeGrad); }
        .eye { transition: transform 0.12s cubic-bezier(0.25, 1, 0.5, 1); }
        .blink { transform: scaleY(0.05) scaleX(1.1); }
        @keyframes breathe { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }
        #face-elements { animation: breathe 5s ease-in-out infinite; }
        #controls { width: 280px; height: 100vh; flex-shrink: 0; background-color: #585858; border-right: 4px solid #000000; box-shadow: inset 4px 0px 0px #828282; display: flex; flex-direction: column; align-items: center; padding: 30px 20px 60px 20px; box-sizing: border-box; gap: 15px; z-index: 5; overflow-y: auto; overflow-x: hidden; }
        #controls::-webkit-scrollbar { width: 10px; }
        #controls::-webkit-scrollbar-track { background: #444; border-left: 2px solid #000; }
        #controls::-webkit-scrollbar-thumb { background: #727272; border: 2px solid #000; }
        #controls::-webkit-scrollbar-thumb:hover { background: #828282; }
        .sidebar-title { font-family: 'Courier New', Courier, monospace; color: white; margin: 0 0 5px 0; font-size: 1.5rem; text-shadow: 2px 2px 0px #000; text-align: center; letter-spacing: 2px; }
        .ui-btn { width: 100%; background-color: #727272; color: #ffffff; border: 2px solid #000000; padding: 12px 10px; font-size: 0.9rem; font-family: 'Courier New', Courier, monospace; font-weight: bold; cursor: pointer; box-shadow: inset -2px -2px 0px #3A3A3A, inset 2px 2px 0px #9E9E9E; text-transform: uppercase; transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s; white-space: nowrap; }
        .ui-btn:hover { background-color: #828282; }
        .ui-btn:active { box-shadow: inset 2px 2px 0px #3A3A3A, inset -2px -2px 0px #9E9E9E; transform: translateY(2px); }
        .ui-btn.active-toggle { background-color: #4CAF50; box-shadow: inset -2px -2px 0px #2E7D32, inset 2px 2px 0px #81C784; }
        .ui-btn.active-toggle:active { box-shadow: inset 2px 2px 0px #2E7D32, inset -2px -2px 0px #81C784; }
        .slider-container { width: 100%; box-sizing: border-box; display: flex; flex-direction: column; gap: 8px; background-color: #444; padding: 10px; border: 2px solid #000; box-shadow: inset -2px -2px 0px #222, inset 2px 2px 0px #666; margin-top: 5px; }
        .slider-label { color: #4FF3FF; font-family: 'Courier New', Courier, monospace; font-size: 0.95rem; font-weight: bold; text-transform: uppercase; text-shadow: 1px 1px 0px #000; text-align: center; }
        .ui-slider { -webkit-appearance: none; appearance: none; width: 100%; box-sizing: border-box; height: 12px; background: #2a2a2a; border: 2px solid #000000; outline: none; box-shadow: inset 2px 2px 0px #111, inset -1px -1px 0px #444; }
        .ui-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 24px; background: #4CAF50; border: 2px solid #000; cursor: pointer; box-shadow: inset -2px -2px 0px #2E7D32, inset 2px 2px 0px #81C784; }
        .ui-slider::-moz-range-thumb { width: 16px; height: 24px; background: #4CAF50; border: 2px solid #000; cursor: pointer; box-shadow: inset -2px -2px 0px #2E7D32, inset 2px 2px 0px #81C784; }
        .slider-controls-row { display: flex; gap: 10px; margin-top: 5px; }
        .slider-controls-row .ui-btn { padding: 5px; font-size: 1.4rem; }
        :fullscreen #controls { display: none; }
        :-webkit-full-screen #controls { display: none; }
        :-moz-full-screen #controls { display: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; backdrop-filter: blur(5px); }
        #start-btn { background-color: #4CAF50; color: white; border: 3px solid #000; padding: 15px 40px; font-size: 1.5rem; font-family: 'Courier New', Courier, monospace; font-weight: bold; cursor: pointer; box-shadow: inset -4px -4px 0px #2E7D32, inset 4px 4px 0px #81C784; text-transform: uppercase; transition: transform 0.1s, background-color 0.1s, box-shadow 0.1s; }
        #start-btn:hover { background-color: #66BB6A; }
        #start-btn:active { box-shadow: inset 4px 4px 0px #2E7D32, inset -4px -4px 0px #81C784; transform: scale(0.96); }
        #status { margin-top: 20px; font-size: 1.1rem; font-family: 'Courier New', Courier, monospace; color: #aaaaaa; text-align: center; }
    </style>
</head>
<body>

    <div id="controls">
        <h2 class="sidebar-title">CONTROLS</h2>
        <button id="fullscreen-btn" class="ui-btn">Fullscreen</button>
        <button id="nav-steve-btn" class="ui-btn">Switch to Steve</button>
        <button id="toggle-eye-btn" class="ui-btn">Shape: Squircle</button>
        <button id="toggle-idle-mouth-btn" class="ui-btn">Idle Mouth: Straight</button>
        <button id="toggle-mouth-btn" class="ui-btn active-toggle">Mouth Line: ON</button>
        
        <button id="toggle-preset-btn" class="ui-btn">Sens: HIGH</button>
        
        <div class="slider-container">
            <div id="threshold-val-display" class="slider-label">Noise Gate: 1.5</div>
            <input type="range" id="threshold-slider" class="ui-slider" min="0.5" max="50" step="0.5" value="1.5">
            <div class="slider-controls-row">
                <button id="gate-down-btn" class="ui-btn">-</button>
                <button id="gate-up-btn" class="ui-btn">+</button>
            </div>
        </div>
    </div>

    <div id="overlay">
        <button id="start-btn">Connect to Backend</button>
        <div id="status">Waiting to connect to Python WebSocket...</div>
    </div>

    <svg viewBox="0 0 800 480" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <radialGradient id="eyeGrad" cx="50%" cy="50%" r="60%">
                <stop offset="50%" stop-color="#00ffff" />
                <stop offset="100%" stop-color="#0088cc" />
            </radialGradient>
        </defs>

        <g id="face-elements">
            <g id="left-squint" style="transform-origin: 265px 175px;">
                <rect class="eye squircle-eye" x="200" y="120" width="130" height="110" rx="40" style="transform-origin: 265px 175px;" />
                <g class="eilik-eye" style="display:none; transform: rotate(-8deg); transform-origin: 265px 175px;">
                    <path class="eye" d="M 215 210 C 240 220, 290 220, 315 210 C 340 190, 340 130, 315 120 C 290 100, 240 100, 215 120 C 190 130, 190 190, 215 210 Z" style="transform-origin: 265px 175px;" />
                </g>
                <path class="eye custom-eye-wide" fill="#22F4FE" style="display:none; transform-origin: 265px 175px;" d="M 195 177.8 C 195 149.8, 237 135.8, 265 135.8 C 290.2 135.8, 323.8 149.8, 323.8 177.8 C 323.8 203, 301.4 214.2, 279 211.4 C 267.8 208.6, 259.4 208.6, 251 211.4 C 225.8 214.2, 195 208.6, 195 177.8 Z" />
                <path class="eye custom-eye-tall" fill="#22F4FE" style="display:none; transform-origin: 265px 175px;" d="M 214.4 178.6 C 214.4 142.6, 247.4 124.6, 269.4 124.6 C 289.2 124.6, 315.6 142.6, 315.6 178.6 C 315.6 211, 298 225.4, 280.4 221.8 C 271.6 218.2, 265 218.2, 258.4 221.8 C 238.6 225.4, 214.4 218.2, 214.4 178.6 Z" />
                <path class="eye custom-eye-nodivot" fill="#22F4FE" style="display:none; transform-origin: 265px 175px;" d="M 214.4 178.6 C 214.4 142.6, 247.4 124.6, 269.4 124.6 C 289.2 124.6, 315.6 142.6, 315.6 178.6 C 315.6 215, 295 228, 265 228 C 235 228, 214.4 215, 214.4 178.6 Z" />
            </g>

            <g id="right-squint" style="transform-origin: 535px 175px;">
                <rect class="eye squircle-eye" x="470" y="120" width="130" height="110" rx="40" style="transform-origin: 535px 175px;" />
                <g class="eilik-eye" style="display:none; transform: rotate(8deg); transform-origin: 535px 175px;">
                    <path class="eye" d="M 485 210 C 510 220, 560 220, 585 210 C 610 190, 610 130, 585 120 C 560 100, 510 100, 485 120 C 460 130, 460 190, 485 210 Z" style="transform-origin: 535px 175px;" />
                </g>
                <path class="eye custom-eye-wide" fill="#22F4FE" style="display:none; transform-origin: 535px 175px;" d="M 465 177.8 C 465 149.8, 507 135.8, 535 135.8 C 560.2 135.8, 593.8 149.8, 593.8 177.8 C 593.8 203, 571.4 214.2, 549 211.4 C 537.8 208.6, 529.4 208.6, 521 211.4 C 495.8 214.2, 465 208.6, 465 177.8 Z" />
                <path class="eye custom-eye-tall" fill="#22F4FE" style="display:none; transform-origin: 535px 175px;" d="M 484.4 178.6 C 484.4 142.6, 517.4 124.6, 539.4 124.6 C 559.2 124.6, 585.6 142.6, 585.6 178.6 C 585.6 211, 568 225.4, 550.4 221.8 C 541.6 218.2, 535 218.2, 528.4 221.8 C 508.6 225.4, 484.4 218.2, 484.4 178.6 Z" />
                <path class="eye custom-eye-nodivot" fill="#22F4FE" style="display:none; transform-origin: 535px 175px;" d="M 484.4 178.6 C 484.4 142.6, 517.4 124.6, 539.4 124.6 C 559.2 124.6, 585.6 142.6, 585.6 178.6 C 585.6 215, 565 228, 535 228 C 505 228, 484.4 215, 484.4 178.6 Z" />
            </g>
            <path id="mouth-path" d="" style="opacity: 1;" />
        </g>
    </svg>

    <script>
    (() => {
        // --- ALL UI LOGIC REMAINS EXACTLY THE SAME ---
        const navSteveBtn = document.getElementById('nav-steve-btn');
        navSteveBtn.addEventListener('click', () => { window.location.href = 'steve.html'; });

        const fullscreenBtn = document.getElementById('fullscreen-btn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => console.log(err)); }
        });

        const toggleEyeBtn = document.getElementById('toggle-eye-btn');
        const squircleEyes = document.querySelectorAll('.squircle-eye');
        const eilikEyes = document.querySelectorAll('.eilik-eye');
        const customWideEyes = document.querySelectorAll('.custom-eye-wide');
        const customTallEyes = document.querySelectorAll('.custom-eye-tall');
        const customNoDivotEyes = document.querySelectorAll('.custom-eye-nodivot');
        let eyeMode = 0; 

        toggleEyeBtn.addEventListener('click', () => {
            eyeMode = (eyeMode + 1) % 5; 
            squircleEyes.forEach(el => el.style.display = (eyeMode === 0) ? 'block' : 'none');
            eilikEyes.forEach(el => el.style.display = (eyeMode === 1) ? 'block' : 'none');
            customWideEyes.forEach(el => el.style.display = (eyeMode === 2) ? 'block' : 'none');
            customTallEyes.forEach(el => el.style.display = (eyeMode === 3) ? 'block' : 'none');
            customNoDivotEyes.forEach(el => el.style.display = (eyeMode === 4) ? 'block' : 'none');
            const modeNames = ["Shape: Squircle", "Shape: Emo/Eilik", "Shape: Wide Bean", "Shape: Tall Bean", "Shape: Smooth Pill"];
            toggleEyeBtn.innerText = modeNames[eyeMode];
        });

        const togglePresetBtn = document.getElementById('toggle-preset-btn');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdDisplay = document.getElementById('threshold-val-display');
        const gateDownBtn = document.getElementById('gate-down-btn');
        const gateUpBtn = document.getElementById('gate-up-btn');
        const presets = [ { label: "Sens: HIGH", val: 1.5 }, { label: "Sens: MED", val: 5.0 }, { label: "Sens: LOW", val: 15.0 }, { label: "Sens: SPKR ONLY", val: 30.0 } ];
        let presetIndex = 0;
        let currentThreshold = presets[presetIndex].val;

        function updateThresholdUI(newVal) {
            currentThreshold = Math.max(0.5, Math.min(50.0, newVal));
            thresholdSlider.value = currentThreshold;
            thresholdDisplay.innerText = `Noise Gate: ${currentThreshold.toFixed(1)}`;
            let matchedPreset = presets.find(p => p.val === currentThreshold);
            if (matchedPreset) {
                togglePresetBtn.innerText = matchedPreset.label;
                presetIndex = presets.indexOf(matchedPreset);
                if (presetIndex === 3) { togglePresetBtn.classList.add('active-toggle'); } else { togglePresetBtn.classList.remove('active-toggle'); }
            } else {
                togglePresetBtn.innerText = "Sens: CUSTOM";
                togglePresetBtn.classList.remove('active-toggle');
            }
        }
        togglePresetBtn.addEventListener('click', () => { presetIndex = (presetIndex + 1) % presets.length; updateThresholdUI(presets[presetIndex].val); });
        thresholdSlider.addEventListener('input', (e) => { updateThresholdUI(parseFloat(e.target.value)); });
        gateDownBtn.addEventListener('click', () => { updateThresholdUI(currentThreshold - 0.5); });
        gateUpBtn.addEventListener('click', () => { updateThresholdUI(currentThreshold + 0.5); });

        const toggleIdleMouthBtn = document.getElementById('toggle-idle-mouth-btn');
        let isIdleSmile = false;
        toggleIdleMouthBtn.addEventListener('click', () => {
            isIdleSmile = !isIdleSmile;
            toggleIdleMouthBtn.innerText = isIdleSmile ? "Idle Mouth: Smile" : "Idle Mouth: Straight";
        });

        const toggleMouthBtn = document.getElementById('toggle-mouth-btn');
        let isPermanentMouth = true;
        toggleMouthBtn.addEventListener('click', () => {
            isPermanentMouth = !isPermanentMouth;
            if (isPermanentMouth) {
                toggleMouthBtn.innerText = "Mouth Line: ON";
                toggleMouthBtn.classList.add('active-toggle');
            } else {
                toggleMouthBtn.innerText = "Mouth Line: OFF";
                toggleMouthBtn.classList.remove('active-toggle');
            }
        });

        let wakeLock = null;
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try { wakeLock = await navigator.wakeLock.request('screen'); } 
                catch (err) { console.error(`Wake Lock error: ${err.message}`); }
            }
        }
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') { await requestWakeLock(); }
        });

        // --- NEW NETWORK AUDIO LOGIC ---
        let animationFrameId;
        const mouthPath = document.getElementById('mouth-path');
        const leftSquint = document.getElementById('left-squint');
        const rightSquint = document.getElementById('right-squint');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('status');
        const mouthCenter = { x: 400, y: 350 };
        const mouthThickness = 10; 
        
        let currentMouth = { w: 75, hTop: 0, hBottom: 0 };
        let targetMouth  = { w: 75, hTop: 0, hBottom: 0 };
        let currentOpacity = 1.0;
        let targetOpacity = 1.0;
        let currentSquint = 1.0;
        let currentSquintY = 0.0;
        let targetSquint = 1.0;
        let targetSquintY = 0.0;

        function lerp(start, end, factor) { return start + (end - start) * factor; }

        // THESE GLOBALS REPLACE analyser.getByteFrequencyData
        let netVolume = 0;
        let netLowAvg = 0;
        let netMidAvg = 0;
        let ws;

        function connectWebSocket() {
            startBtn.innerText = "Connecting...";
            statusText.innerText = "Establishing WebSocket link...";

            // Automatically grabs the IP of the machine hosting the website
            const wsUrl = 'ws://localhost:7000'; 
            ws = new WebSocket(wsUrl);

            ws.onopen = async () => {
                overlay.style.display = 'none';
                await requestWakeLock();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(animateFace);
                scheduleBlink();
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                netVolume = data.v;
                netLowAvg = data.l;
                netMidAvg = data.m;
            };

            ws.onerror = (err) => {
                console.error("WebSocket Error:", err);
                overlay.style.display = 'flex';
                statusText.innerText = "Error: Cannot connect to Python backend.";
                startBtn.innerText = "Try Again";
            };

            ws.onclose = () => {
                overlay.style.display = 'flex';
                statusText.innerText = "Connection lost. Please restart.";
                startBtn.innerText = "Reconnect";
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
            };
        }

        startBtn.addEventListener('click', connectWebSocket);

        // --- ANIMATION LOOP (Untouched Math, only reads from globals now) ---
        function animateFace() {
            // We just map the incoming network data to the exact same variables
            let volume = netVolume;
            let lowAvg = netLowAvg;
            let midAvg = netMidAvg;

            if (volume > currentThreshold) { 
                let volFactor = Math.min(volume / 15, 1.3); 

                targetOpacity = 1.0;
                targetSquint = 1.0 - (volFactor * 0.15); 
                targetSquintY = -(volFactor * 8);

                if (midAvg > lowAvg * 1.1) {
                    targetMouth = { w: 80 + (volFactor * 30), hTop: 5 + (volFactor * 5), hBottom: 30 + (volFactor * 70) };
                } else if (lowAvg > midAvg * 1.1) {
                    targetMouth = { w: 45 + (volFactor * 15), hTop: 25 + (volFactor * 40), hBottom: 25 + (volFactor * 50) };
                } else {
                    targetMouth = { w: 75 + (volFactor * 15), hTop: 5 + (volFactor * 10), hBottom: 20 + (volFactor * 35) };
                }
            } else {
                targetSquint = 1.0;
                targetSquintY = 0.0;
                
                if (isIdleSmile) {
                    targetMouth = { w: 65, hTop: -25, hBottom: 25 }; 
                } else {
                    targetMouth = { w: 75, hTop: 0, hBottom: 0 };
                }
                
                targetOpacity = isPermanentMouth ? 1.0 : 0.0;
            }

            // Exactly the same lerping and SVG drawing
            currentMouth.w = lerp(currentMouth.w, targetMouth.w, 0.15);
            currentMouth.hTop = lerp(currentMouth.hTop, targetMouth.hTop, 0.15);
            currentMouth.hBottom = lerp(currentMouth.hBottom, targetMouth.hBottom, 0.15);
            
            currentSquint = lerp(currentSquint, targetSquint, 0.15);
            currentSquintY = lerp(currentSquintY, targetSquintY, 0.15);
            currentOpacity = lerp(currentOpacity, targetOpacity, 0.15);

            leftSquint.setAttribute('transform', `translate(0, ${currentSquintY}) scale(1, ${currentSquint})`);
            rightSquint.setAttribute('transform', `translate(0, ${currentSquintY}) scale(1, ${currentSquint})`);
            mouthPath.style.opacity = currentOpacity;

            const x1 = mouthCenter.x - currentMouth.w;
            const x2 = mouthCenter.x + currentMouth.w;
            const y1 = mouthCenter.y - mouthThickness;
            const y2 = mouthCenter.y + mouthThickness;
            
            const cpYTop = y1 - currentMouth.hTop;
            const cpYBot = y2 + currentMouth.hBottom;

            const d = `
                M ${x1} ${y1}
                Q ${mouthCenter.x} ${cpYTop} ${x2} ${y1}
                A ${mouthThickness} ${mouthThickness} 0 0 1 ${x2} ${y2}
                Q ${mouthCenter.x} ${cpYBot} ${x1} ${y2}
                A ${mouthThickness} ${mouthThickness} 0 0 1 ${x1} ${y1}
                Z
            `;
            
            mouthPath.setAttribute('d', d);

            animationFrameId = requestAnimationFrame(animateFace);
        }

        function triggerBlink() {
            const eyes = document.querySelectorAll('.eye:not([style*="display: none"])');
            eyes.forEach(eye => eye.classList.add('blink'));
            setTimeout(() => { eyes.forEach(eye => eye.classList.remove('blink')); }, 120); 
        }

        function scheduleBlink() {
            const nextBlink = Math.random() * 3500 + 2000; 
            setTimeout(() => {
                triggerBlink();
                if (Math.random() < 0.20) { setTimeout(triggerBlink, 200); }
                scheduleBlink();
            }, nextBlink);
        }
    })();
    </script>
</body>
</html>